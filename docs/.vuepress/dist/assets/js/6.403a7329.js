(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{192:function(t,e,a){"use strict";a.r(e);var s=a(0),n=Object(s.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("GraphQL in .NET Core is a little bit different than the JavaScript implementation. Not a whole lot though.")]),t._v(" "),a("p",[t._v("What is the same are the following concepts")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Schema")]),t._v(", we still have the idea of a schema, something that specifies what Entities we have, what we can Query, what we can Mutate and so on")]),t._v(" "),a("li",[a("strong",[t._v("Resolver")]),t._v(", we still have the concept of a Resolver, a piece of code that should be invoked when a Query or Mutation is made.")]),t._v(" "),a("li",[a("strong",[t._v("GQL")]),t._v(", we still have the GraphQL Query Language to define our schema and we also use it to construct queries and mutations to try to read/write data")])]),t._v(" "),a("blockquote",[a("p",[t._v("So what is different?")])]),t._v(" "),a("p",[t._v("The difference lies in how we resolve a query. The first thing we do when resolving a Query in GraphQL is to ensure the resource we ask for exist. If it does we invoke the corresponding Function. Below is same pseudo code the explains the difference in approach")]),t._v(" "),a("p",[t._v("##Â JS Approach")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// JavaScript")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" resolverObject "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("hello")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolver")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("In GQL we would ask for the resource "),a("code",[t._v("hello")]),t._v(". The inner core would find the resolver object and invoke the "),a("code",[t._v("resolver()")]),t._v(" function.")]),t._v(" "),a("h2",{attrs:{id:"c-approach"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#c-approach","aria-hidden":"true"}},[t._v("#")]),t._v(" C# Approach")]),t._v(" "),a("div",{staticClass:"language-csharp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-csharp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// C#")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Query")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("GraphQLMetadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("string")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("GetHello")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"World"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Above we have the C# approach in which we have a "),a("code",[t._v("Query")]),t._v(" class and a method that is decorated with an attribute class "),a("code",[t._v("GraphQLMetadata")]),t._v(" and a parameter "),a("code",[t._v("hello")]),t._v(" which is the resource it resolves. Invoking our "),a("code",[t._v("GetHello()")]),t._v(" method would give us the answer we seek.")]),t._v(" "),a("p",[t._v("That is a very brief explanation of how JavaScript and C# differs.")])])},[],!1,null,null,null);e.default=n.exports}}]);