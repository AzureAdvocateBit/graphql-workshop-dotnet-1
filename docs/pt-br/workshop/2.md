---
title: üîé API do GraphQL
---
# üîé GraphQL

Primeiro, fa√ßamos uma pequena introdu√ß√£o √† GraphQL e √†s diferentes partes em que ela consiste. 

## Conceitos

- **Esquema** ‚Äì √© onde voc√™ definir√° os tipos de dados e as coisas que voc√™ poder√° consultar
- **Resolvedores** ‚Äì s√£o fun√ß√µes invocadas quando voc√™ solicita algo do esquema. Seus resolvedores devem responder com dados ou alterar os dados, dependendo da funcionalidade pretendida.

## Nosso primeiro aplicativo Ol√°, Mundo

A maneira mais f√°cil de entender a GraphQL √© criar algo com ela e aprender na pr√°tica.

Usaremos algo chamado `GQL` ou **L**inguagem de **C**onsulta **G**raphQL. Definimos nosso primeiro esquema simples da seguinte forma:

### Esquema

```
type Query {
  hello: String
}
```

Neste ponto, definimos o tipo interno `Query` e estamos dizendo que h√° uma coisa que podemos consultar, ou seja, `hello`. Observe como depois que `:` est√° dizendo `string`. Trata-se de dizer qual √© o tipo de retorno para `hello`;

Isso significa que podemos executar uma consulta como a seguinte:

```
{
  hello
}
```

N√£o receberemos uma resposta neste ponto porque n√£o conectamos a uma fun√ß√£o de resolvedor que sabe como responder. 

Agora, a conex√£o de um esquema a um resolvedor √© feita de maneira diferente, dependendo de qual biblioteca voc√™ usa para criar seu servidor GraphQL.

### Resolvedor

Vamos definir um resolvedor como na maioria das implementa√ß√µes:

```csharp
public class Query 
{
  [GraphQLMetadata("hello")]
  public string GetHello() 
  {
      return "World";
  }
}
```

### Tipo personalizado

Na GraphQL, voc√™ tem primitivos diferentes, tamb√©m chamados de tipos escalares, que podem servir como entradas, tipos de retorno. Voc√™ tamb√©m pode combinar v√°rios primitivos para formar um tipo personalizado. Vamos primeiro mencionar quais s√£o esses primitivos:

- **Cadeia de caracteres** ‚Äì √â o tipo tradicional de cadeia de caracteres, que armazena os caracteres da cadeia de caracteres
- **ID** ‚Äì Representa um identificador exclusivo, significa que n√£o se destina a ser leg√≠vel para humanos
- **Float** ‚Äì Um valor num√©rico de ponto flutuante com precis√£o dupla
- **Int**. Representa um n√∫mero inteiro de 32 bits com sinal
- **Boolean** ‚Äì Armazena os valores true ou false

At√© agora, temos apenas a propriedade pass√≠vel de consulta `hello` e uma fun√ß√£o de resolvedor. √â prov√°vel que voc√™ queira criar algo mais avan√ßado do que isso e combinando os escalares em um grupo podemos criar um tipo personalizado da seguinte forma:

```
type Person {
  id: ID!
  name: String,
  address: String,
  speaker: Boolean
}
```

Observe que come√ßamos a usar o caractere de exclama√ß√£o `!` no campo `id`, o que significa que esse valor n√£o pode ser *nulo*, ou seja, n√£o podemos deix√°-lo de fora.

Tamb√©m podemos, conforme mencionado, usar o tipo personalizado em nosso esquema para que possamos estend√™-lo para que fique assim:

```
type Person {
  id: ID!
  name: String,
  address: String,
  speaker: Boolean
}

type Query {
  hello: string,
  person: Person
}
```

Isso significa que agora precisamos de uma nova fun√ß√£o de resolvedor, como:

```csharp
public class Query 
{
  [GraphQLMetadata("hello")]
  public string GetHello() 
  {
    return "World";
  }

  [GraphQLMetadata("person")]
  public Person GetPerson() 
  {
    return new Person()
    { 
      Id=1, 
      Name="Jen",
      Address ="One Microsoft Way Redmond USA",
      Speaker = True
    };
  }
}

```

### Tipo de lista

O tipo de lista significa que podemos definir no esquema para obter uma matriz de qualquer item, da seguinte forma:

```
type Person {
  id: ID!
  name: String,
  address: String,
  speaker: Boolean
}

type Query {
  hello: string,
  person: Person,
  people: [Person]
}
```

Adicionamos o tipo pass√≠vel de consulta `people` que tem o tipo de retorno `[Person]` que significa simplesmente uma lista do tipo `Person`. Isso certamente significa que precisamos adicionar uma fun√ß√£o de resolvedor para ele, para estendermos nosso objeto resolvedor com outra fun√ß√£o `people`:

```csharp
public class Query 
{
  [GraphQLMetadata("hello")]
  public string GetHello() 
  {
    return "World";
  }

  [GraphQLMetadata("person")]
  public Person GetPerson() 
  {
    return new Person()
    { 
      Id=1, 
      Name="Jen",
      Address ="One Microsoft Way Redmond USA",
      Speaker = True
    };
  }

  [GraphQLMetadata("people")]
  public List<Person> GetPeople() 
  {
    return new new List<Person>(){
      new Person()
      { 
        Id=1, 
        Name="Jen",
        Address ="One Microsoft Way Redmond USA",
        Speaker = True
      },
      new Person()
      { 
        Id=2, 
        Name="Chris",
        Address ="One Microsoft Way Redmond USA",
        Speaker = True
      }
    };
  }
}
```

## Consulta com argumento

Agora, voc√™ certamente desejar√° filtrar sua resposta em algum momento para poder solicitar um item espec√≠fico. Imagine que voc√™ n√£o queira obter a lista completa de pessoas, mas apenas uma pessoa espec√≠fica. Para esse caso de uso, podemos expor um tipo pass√≠vel de consulta que admita um par√¢metro, da seguinte forma:

```
type Person {
  id: ID!
  name: String,
  address: String,
  speaker: Boolean
}

type Query {
  hello: string,
  person: Person,
  people: [Person],
  getPerson(id: ID!): Person
}
```

Agora, para adicionar isso ao nosso objeto resolvedor, s√≥ precisamos adicionar uma propriedade de nome correspondente `getPerson`, mas tamb√©m precisamos extrair o par√¢metro do objeto de solicita√ß√£o de entrada:

```csharp
var people = new List<Person>()
{
  new Person()
  { 
    Id=1, 
    Name="Jen",
    Address ="One Microsoft Way Redmond USA",
    Speaker = True
  },
  new Person()
  { 
    Id=2, 
    Name="Chris",
    Address ="One Microsoft Way Redmond USA",
    Speaker = True
  }
};

public class Query 
{
  [GraphQLMetadata("hello")]
  public string GetHello() 
  {
    return "World";
  }

  [GraphQLMetadata("person")]
  public Person GetPerson() 
  {
    return new Person()
    { 
      Id=1, 
      Name="Jen",
      Address ="One Microsoft Way Redmond USA",
      Speaker = True
    };
  }

  [GraphQLMetadata("people")]
  public List<Person> GetPeople() 
  {
    return people;
  }

  [GraphQLMetadata("getPerson")]
  public Person GetPersonById(int id) 
  {
    return people.SingleOrDefault( p => p.Id == id);
  }
}
```

## Muta√ß√£o

At√© agora, n√≥s nos concentramos na aprendizagem de tipos escalares e de tipos personalizados e em como criar nosso objeto resolvedor para poder responder a todas as consultas, o que √© o *b√°sico* para o dom√≠nio da GraphQL. Mas h√° outro constructo que precisamos conhecer para poder criar uma API CRUD (da sigla em ingl√™s, **C**riar **L**er **A**tualizar e **E**xcluir): as *muta√ß√µes*. Uma *Muta√ß√£o* √© algo que, na GraphQL, sinaliza que queremos alterar algo, seja criando algo novo ou atualizando ou removendo algo existente. 

Vamos come√ßar com uma Muta√ß√£o muito simples ‚Äì adicionar um item a uma lista:

```
type Mutation {
  addItem(item: String): String
}
```

Assim como qualquer coisa dentro de um `Query` podemos invocar qualquer coisa dentro dele, como uma API p√∫blica, para que possamos chamar `addItem` da seguinte forma:

```
addItem(item: "my new item")
```

Na maioria das vezes, voc√™ pode querer um tipo de entrada mais complexo do que um escalar. Isso √© necess√°rio para criar esse tipo de entrada, da seguinte forma:

```
input ProductInput {
  id: ID!
  name: String,
  address: String,
  speaker: Boolean
}
```

Como voc√™ pode ver, √© basicamente id√™ntico ao nosso `type Person` e n√£o podemos usar aquele, precisamos definir algo do tipo `input`, como mostrado acima. Vamos adicionar uma propriedade `addPerson` ao nosso esquema:

```
input PersonInput {
  id: ID!
  name: String,
  address: String,
  speaker: Boolean
}

type Person {
  id: ID!
  name: String,
  address: String,
  speaker: Boolean
}

type Mutation {
  addPerson(person: PersonInput): Person
}

type Query {
  hello: string,
  person: Person,
  people: [Person],
  getPerson(id: ID!): Person
}
```

Para invocar essa muta√ß√£o `addPerson`, digitamos:

```
addPerson(person: { id: 3, name: 'Amy', address: `One Microsoft Way Redmond USA`, speaker: true }) {
  name
}
```

Observe que obtemos um tipo de retorno do tipo `Person`, portanto, precisamos selecionar uma ou mais colunas √† medida que estamos inserindo uma pessoa, mas consultando a resposta.

Por fim, vamos adicionar a fun√ß√£o de resolvedor ao objeto:

```csharp
var people = new List<Person>()
{
  new Person()
  { 
    Id=1, 
    Name="Jen",
    Address ="One Microsoft Way Redmond USA",
    Speaker = True
  },
  new Person()
  { 
    Id=2, 
    Name="Chris",
    Address ="One Microsoft Way Redmond USA",
    Speaker = True
  }
};

public class Query 
{
  [GraphQLMetadata("hello")]
  public string GetHello() 
  {
    return "World";
  }

  [GraphQLMetadata("person")]
  public Person GetPerson() 
  {
    return new Person()
    { 
      Id=1, 
      Name="Jen",
      Address ="One Microsoft Way Redmond USA",
      Speaker = True
    };
  }

  [GraphQLMetadata("people")]
  public List<Person> GetPeople() 
  {
    return people;
  }

  [GraphQLMetadata("getPerson")]
  public Person GetPersonById(int id) 
  {
    return people.SingleOrDefault( p => p.Id == id);
  }
}

[GraphQLMetadata("Mutation")]
public class Mutation {
  public String addPerson(Person person) 
  {
    people.push(person);
    return "Success creating " + person;
  } 
}
```

## Tipo aninhado

Muitas vezes, queremos fazer consultas em que consultamos em profundidade e podemos ter um esquema semelhante ao seguinte:

```
type Person {
  id: ID!
  name: String,
  address: String,
  speaker: Boolean,
  friend: Person
}
```

Observe em especial a propriedade `friend`. H√° duas perguntas que precisam de resposta aqui:

1. como armazenar os dados?
2. como resolver `friend`?

Duas boas perguntas e a resposta √© simples. Quanto √† forma de armazenar os dados, a resposta √© que a nossa propriedade `friend` precisa apontar para um primitivo que representa o identificador exclusivo, o que significa que os dados precisam ter a seguinte apar√™ncia:

```csharp
var person = new Person()
{
  Id = 1,
  Name = "Jen",
  Address = "One Microsoft Way Redmond USA",
  Speaker = True,
  Friend = 2
};
```

Observe como `friend` tem valor `2`. 

Agora a pr√≥xima pergunta, como resolver isso? Quando dizemos resolver, estamos nos referindo a como dar suporte a consultas como esta:

```
{
  person {
    id,
    name,
    address,
    friend {
      name
    }
  }
}
```

Como dissemos, √© bem simples quando sabemos como fazer. Vamos ao objeto resolvedor e vamos atualiz√°-lo da seguinte forma:

```csharp
var people = new List<Person>()
{
  new Person()
  { 
    Id=1, 
    Name="Jen",
    Address ="One Microsoft Way Redmond USA",
    Speaker = True,
    Friend = 2
  },
  new Person()
  { 
    Id=2, 
    Name="Chris",
    Address ="One Microsoft Way Redmond USA",
    Speaker = True,
    Friend = 1
  }
};

public class Query 
{
  [GraphQLMetadata("hello")]
  public string GetHello() 
  {
    return "World";
  }

  [GraphQLMetadata("person")]
  public Person GetPerson() 
  {
    return new Person()
    { 
      Id=1, 
      Name="Jen",
      Address ="One Microsoft Way Redmond USA",
      Speaker = True
    };
  }

  [GraphQLMetadata("people")]
  public List<Person> GetPeople() 
  {
    return people;
  }

  [GraphQLMetadata("getPerson")]
  public Person GetPersonById(int id) 
  {
    return people.SingleOrDefault( p => p.Id == id);
  }
}

[GraphQLMetadata("Mutation")]
public class Mutation {
  public String addPerson(Person person) 
  {
    people.push(person);
    return "Success creating " + person;
  } 
}

// this is used to resolve `friend`
[GraphQLMetadata("Person", IsTypeOf=typeof(Person))]
public class PersonResolver 
{
  public Person Friend(ResolveFieldContext context, Person source)
  {
    return people.SingleOrDefault(p => p.Id == source.Friend);
  }
}
```

Observe a adi√ß√£o de `Person` e sua propriedade interna `friend` que aponta para uma fun√ß√£o de resolvedor que recebe o valor `2`, o qual pode ser resolvido filtrando-o da lista `people`.


## O que vamos criar?

Criaremos uma GraphQL que consiste em dois recursos diferentes, `Products` e `Reviews`. S√£o dois objetivos:

1. Demonstrar como criar uma API da GraphQL
2. Aprender como criar uma API para dar suporte a consultas aninhadas

### Parte I ‚Äì Instalando e configurando

Supomos que voc√™ j√° tenha instalado o .NET Core. Caso n√£o tenha, v√° para a [p√°gina de instala√ß√£o](https://docs.microsoft.com/dotnet/core/install/windows?pivots=os-windows&tabs=netcore31&WT.mc_id=graphql-workshop-gllemos)

**Inicializar um projeto no .NET Core**

```bash
> dotnet new console -o api
```

Isso criar√° um projeto `console`. Voc√™ poder√° perfeitamente criar um projeto Web se quiser dar suporte a coisas como `graphiql`, um ambiente visual para experimentar suas consultas.

**Instalar as depend√™ncias** Agora voc√™ est√° pronto para a pr√≥xima etapa, que √© instalar a GraphQL. Vamos fazer isso com o seguinte comando:

Verifique se voc√™ est√° no diret√≥rio `API`.

```bash
> dotnet add package GraphQL
```

> Atualmente, eu defini meu aplicativo .NET Core como 2.2

**Criar o servidor**

Faremos o seguinte:

- Definir esquema
- Definir uma classe de consulta
- Executar uma consulta

Abra `Program.cs` e adicione o seguinte na parte superior do arquivo:

```
using GraphQL;
using GraphQL.Types;
```

no m√©todo `Main()`:

```csharp
var schema = Schema.For(@"
  type Query {
      hello: String
  }
  ", _ =>
  {
  _.Types.Include<Query>();
  });
```

Depois adicione a classe `Query` no arquivo `Program.cs`, da seguinte forma:

```csharp
using GraphQL;

public class Query
{
  [GraphQLMetadata("hello")]
  public string GetHello()
  {
  return "World";
  }
}
```

Agora, para executar uma consulta, precisamos do seguinte c√≥digo, ainda no m√©todo `Main()`:

```csharp
var json = schema.Execute(_ =>
{
    _.Query = "{ hello }";
});

Console.WriteLine(json);
```

Em seguida, executaremos isso. Fazemos isso digitando o seguinte no terminal:

```bash
> dotnet run
```

Agora, voc√™ dever√° encontrar algo como:

```json
{
  "data": {
    "hello": "World"
  }
}
```

### Parte II ‚Äì Tipos personalizados

Nesta pr√≥xima parte, vamos pegar nosso aplicativo existente e dar a ele alguns outros tipos, como `products`. Mostraremos como fazer para:

- **consultar** todos os produtos
- **consultar** um produto espec√≠fico
- **criar** um produto

Vamos come√ßar. 

**Refatora√ß√£o**

A primeira coisa que faremos √© separar os `Program.cs` em v√°rios arquivos:

- **Program.cs** s√≥ ser√° usado para executar consultas no esquema
- **Schema.cs** conter√° a defini√ß√£o do esquema
- **Query.cs** conter√° o objeto resolvedor

O conte√∫do desses arquivos agora deve ser:

```csharp
// Query.cs

using GraphQL.Types;
using GraphQL;

namespace app 
{
  public class Query
  {
    [GraphQLMetadata("hello")]
    public string GetHello()
    {
      return "World";
    }
  }
}
```

```csharp
// Schema.cs

using GraphQL.Types;
using GraphQL;

namespace app 
{
  public class SchemaFactory 
  {
    public static ISchema Create() 
    {
      var schema = Schema.For(@"
          type Query {
              hello: String
          }
      ", _ =>
      {
        _.Types.Include<Query>();
      });
      return schema;
    }
  }
}
```

```csharp
// Program.cs

using System;
using GraphQL;
using GraphQL.Types;

namespace app
{
    class Program
    {
        static void Main(string[] args)
        {
            var schema = SchemaFactory.Create();
            var json = schema.Execute(_ =>
            {
                _.Query = "{ hello }";
            });

            Console.WriteLine(json);
        }
    }
}
```

**Adicionando um tipo personalizado e algumas novas consultas**

Ok, agora que adicionamos um tipo personalizado, vamos abrir `Schema.cs` e adicionar o tipo personalizado `Product`:

```csharp
// Schema.cs

using GraphQL.Types;
using GraphQL;

namespace app
{
  public class SchemaFactory
  {
    public static ISchema Create()
    {
      var schema = Schema.For(@"
          type Product {
            id: ID,
            name: String
          }

          type Query {
            hello: String,
            products: [Product],
            product(id: ID!): Product
          }
      ", _ =>
      {
        _.Types.Include<Query>();
      });
      return schema;
    }
  }
}
```

Acima, adicionamos o tipo personalizado `Product` fazendo o seguinte:

```
type Product {
  id: ID,
  name: String
}
```

Em seguida, adicionamos o seguinte ao tipo `Schema.cs`:

```
products: [Product],
product(id: ID!): Product
```

A primeira linha significa que podemos consultar `products` e esperar obter uma matriz de produtos como retorno, conforme indicado pelo s√≠mbolo de matriz `[]`.

A segunda `product(id: ID!)`, significa que adicionamos uma consulta que tornou poss√≠vel consultar `product`, mas precisa de um par√¢metro `id`. 

Veja abaixo como voc√™ faria para invocar: 

```
{
  products {
    name
  }
  product(id: 1) { 
    name 
  }
}
```

**Adicionando resolvedores**

Precisamos adicionar m√©todos resolvedores para ser capaz de responder se o usu√°rio digita `products` ou `product`. Para isso, vamos abrir `Query.cs` e verificar se est√° semelhante ao seguinte:

```csharp
// Query.cs

using GraphQL.Types;
using GraphQL;
using System.Linq;
using System.Collections.Generic;

namespace app
{
  public class Product 
  {
    public int Id { get; set; }
    public string Name { get; set; }
  }
  public class Query
  {
    public static List<Product> Products = new List<Product>()
    {
      new Product()
      {
        Id = 1,
        Name = "Avengers - End Game"
      }
    };

    [GraphQLMetadata("hello")]
    public string GetHello()
    {
      return "World";
    }

    [GraphQLMetadata("products")]
    public List<Product> GetProducts()
    {
      return Data.Products;
    }

    [GraphQLMetadata("product")]
    public Product GetProductById(int id)
    {
      return Data.Products.SingleOrDefault( p => p.Id == id );
    }
  }
} 
```

Acima, adicionamos os m√©todos `GetProducts()` e `GetProductById()` respectivamente. 

Observe que, para obter os par√¢metros de entrada, precisamos apenas especific√°-los como par√¢metros de entrada em que eles s√£o usados com o m√©todo `GetProductById()`

Em segundo lugar, adicionaremos o arquivo `Data.cs`, um reposit√≥rio de dados est√°ticos que conter√° todos os dados que queremos consultar e alterar. 

```csharp
// Data.cs
using System.Collections.Generic;

namespace app 
{
  public class Data 
  {
    public static List<Product> Products = new List<Product>()
    {
      new Product()
      {
        Id = 1,
        Name = "Avengers - End Game"
      }
    };
  }
}
```

Por fim, altere `Program.cs` para ter a seguinte apar√™ncia:

```csharp
using System;
using GraphQL;
using GraphQL.Types;

namespace app
{
  class Program
  {
    static void Main(string[] args)
    {
      var schema = SchemaFactory.Create();
      var json = schema.Execute(_ =>
      {
        _.Query = "{ products { name } product(id: 1){ name  } }";
      });

      Console.WriteLine(json);
    }
  }
}
```

Seguido por `dotnet run`, isso deve gerar a seguinte sa√≠da no terminal:

```json
{
  "data": {
    "products": [
      {
        "name": "Avengers - End Game"
      }
    ],
    "product": {
      "name": "Avengers - End Game"
    }
  }
}
```

**Dando suporte a 'criar produto' ‚Äì Adicionando muta√ß√µes**

Agora que sabemos como dar suporte a consultas, vamos examinar como dar suporte a cen√°rios em que adicionamos dados. Ofereceremos suporte √† cria√ß√£o de produtos. A maneira como fazemos isso √© adicionando uma muta√ß√£o. Vamos come√ßar com a atualiza√ß√£o do arquivo de esquema `Schema.cs`:

```csharp
using GraphQL.Types;
using GraphQL;

namespace app
{
  public class SchemaFactory
  {
    public static ISchema Create()
    {
      var schema = Schema.For(@"
          type Product {
            id: ID,
            name: String
          }

          input ProductInput {
            name: String
          }

          type Mutation {
            createProduct(product: ProductInput): Product
          }

          type Query {
            hello: String,
            products: [Product],
            product(id: ID!): Product
          }
      ", _ =>
      {
        _.Types.Include<Query>();
        _.Types.Include<Mutation>();
      });
      return schema;
    }
  }
}
```

Acima, adicionamos o tipo `Mutation` e nele adicionamos `createProduct`, que usa um par√¢metro `product` do tipo `ProductInput`. Tamb√©m podemos ver que precisamos retornar algo do tipo `Product`. `ProductInput` √© do tipo `input` e √© algo que usamos apenas com muta√ß√µes.  Tamb√©m adicionamos essa linha ` _.Types.Include<Mutation>();` para dar suporte √† classe `Mutation` que estamos prestes a criar, em seguida.


Ok, conseguimos a explica√ß√£o do contrato, vamos criar o arquivo `Mutation.cs` e dar a ele o seguinte conte√∫do:

```csharp
// Mutation

using GraphQL.Types;
using GraphQL;
using System.Linq;
using System.Collections.Generic;

namespace app
{
  public class Mutation
  {
    [GraphQLMetadata("createProduct")]
    public Product CreateProduct(Product product)
    {
      product.Id = Data.Products.Count() + 1;
      Data.Products.Add(product);
      return product;
    }
  }
}
```

Acima, adicionamos o m√©todo `CreateProduct()`. Tamb√©m adicionamos a propriedade `Mutation` do objeto que acabamos exportando. 

Para testar essa muta√ß√£o, altere `Program.cs` para o seguinte:

```csharp
using System;
using GraphQL;
using GraphQL.Types;

namespace app
{
  class Program
  {
    static void Main(string[] args)
    {
      var schema = SchemaFactory.Create();
      var json = schema.Execute(_ =>
      {
        _.Query = "mutation { createProduct(product: { name: \"Captain America - the first Avenger\" }) { name }  }";
      });

      Console.WriteLine(json);
    }
  }
}
```

Observe que a nossa consulta agora diz o seguinte:

```csharp
_.Query = "mutation { createProduct(product: { name: \"Captain America - the first Avenger\" }) { name }  }"
```

Acima, usamos a palavra-chave `mutation`. A palavra-chave `mutation`, opcionalmente, usar√° um argumento se voc√™ quiser ter uma muta√ß√£o nomeada. Se voc√™ quiser muitas delas, precisar√° nome√°-las. Isso est√° al√©m do escopo deste workshop.

### Parte II ‚Äì Adicionando revis√µes e dando suporte a consultas aninhadas

Agora, estenderemos nosso esquema com o tipo personalizado `Review` e tamb√©m daremos suporte a consultas aninhadas. 

Para conseguir isso, precisamos fazer o seguinte:

1. Adicionar uma defini√ß√£o de tipo personalizado para `Review` para `Schema.cs`
2. Adicionar dados em mem√≥ria para revis√µes em `Data.cs`
3. Adicionar fun√ß√£o de resolvedor a `Query.cs`
4. Experimentar 

**Adicionar uma defini√ß√£o de tipo personalizado**

A defini√ß√£o de `Review` deve ter a seguinte apar√™ncia:

```
type Review {
  grade: Int,
  title: String,
  description: String,
  product: Product
}
```

nosso `Schema.cs` deve ter a seguinte apar√™ncia:

```csharp
using GraphQL.Types;
using GraphQL;

namespace app
{
  public class SchemaFactory
  {
    public static ISchema Create()
    {
      var schema = Schema.For(@"
          type Product {
            id: ID,
            name: String
          }

          type Review {
            grade: Int,
            title: String,
            description: String,
            product: Product
          }

          input ProductInput {
            name: String
          }

          type Mutation {
            createProduct(product: ProductInput): Product
          }

          type Query {
            hello: String,
            products: [Product],
            product(id: ID!): Product,
            reviews: [Review]
          }
      ", _ =>
      {
        _.Types.Include<Query>();
        _.Types.Include<Mutation>();
      });
      return schema;
    }
  }
}
```

**Adicionar dados em mem√≥ria**

Verifique se `Data.cs` agora tem a seguinte apar√™ncia:

```csharp
// Data.cs

using System.Collections.Generic;

namespace app 
{

  public class Product
  {
    public int Id { get; set; }
    public string Name { get; set; }
  }

  public class Review
  {
    public int Grade { get; set; }
    public string Title { get; set; }
    public string Description { get; set; }
    public int Product { get; set; }
  }
  public class Data 
  {
    public static List<Product> Products = new List<Product>()
    {
      new Product()
      {
        Id = 1,
        Name = "Avengers - End Game"
      }
    };

    public static List<Review> Reviews = new List<Review>()
    {
      new Review()
      {
        Grade = 5,
        Title = "Great movie",
        Description = "Great actor playing Thanos",
        Product = 1
      }
    }
  }
}
```

Observe que movemos a classe `Product` para `Data.cs` e a removemos de `Query.cs`. 

Agora, vamos adicionar um m√©todo `GetReviews()` √† classe `Query.cs`, da seguinte maneira:

```csharp
[GraphQLMetadata("reviews")]
public Product GetReviews()
{
  return Data.Reviews;
}
```

`Query.cs`, neste ponto, deve ter a seguinte apar√™ncia:

```csharp
// Query.cs

using GraphQL.Types;
using GraphQL;
using System.Linq;
using System.Collections.Generic;

namespace app
{
  public class Query
  {
    [GraphQLMetadata("hello")]
    public string GetHello()
    {
      return "World";
    }

    [GraphQLMetadata("products")]
    public List<Product> GetProducts()
    {
      return Data.Products;
    }

    [GraphQLMetadata("product")]
    public Product GetProductById(int id)
    {
      return Data.Products.SingleOrDefault( p => p.Id == id );
    }

    [GraphQLMetadata("reviews")]
    public Product GetReviews()
    {
      return Data.Reviews;
    }
  }
} 
```

**Adicionar fun√ß√£o de resolvedor aninhada**

Estamos prestes a dar suporte a uma consulta como esta:

```
{
  reviews {
    product { name }
  }
}
```

Para que seja poss√≠vel, precisamos de uma fun√ß√£o com a capacidade de transformar um inteiro em um objeto `Product`. Por que estou dizendo isso? Examine os dados de revis√£o mais uma vez:

```csharp
new Review()
{
  Grade = 5,
  Title = "Great movie",
  Description = "Great actor playing Thanos",
  Product = 1
}
```

O campo `Product` est√° apontando para `1`, n√£o para um objeto `Product`. Como corrigir? Bem, a GraphQL tentar√° resolver isso para n√≥s, contanto que forne√ßamos a ela um provedor do tipo `Review`, que √© capaz de resolver nosso campo `Product`. O Provedor deve ser algo semelhante ao seguinte:

```csharp
[GraphQLMetadata("Review", IsTypeOf = typeof(Review))]
public class ReviewResolver
{
  public string Title(Review review) => review.Title;
  public string Description(Review review) => review.Description;
  public int Grade(Review review) => review.Grade;
  public Product Product(ResolveFieldContext context, Review review)
  {
    return Data.Products.SingleOrDefault(p => p.Id == review.Product);
  }
}
```

O que estamos dizendo acima √© que os campos simples s√£o facilmente resolvidos da seguinte maneira:

```csharp
public string Title(Review review) => review.Title;
```

enquanto os campos que s√£o inteiros, que sabemos que apontam para objetos reais, de acordo com nosso esquema, ser√£o resolvidos por m√©todos como o m√©todo `Product()`, que procura ativamente o `1` e o transforma em um `Product`.

Nosso `Query.cs` deve ter a seguinte apar√™ncia:

```csharp
using GraphQL.Types;
using GraphQL;
using System.Linq;
using System.Collections.Generic;

namespace app
{
  public class Query
  {
    [GraphQLMetadata("hello")]
    public string GetHello()
    {
      return "World";
    }

    [GraphQLMetadata("products")]
    public List<Product> GetProducts()
    {
      return Data.Products;
    }

    [GraphQLMetadata("product")]
    public Product GetProductById(int id)
    {
      return Data.Products.SingleOrDefault( p => p.Id == id );
    }

    [GraphQLMetadata("reviews")]
    public List<Review> GetReviews()
    {
      return Data.Reviews;
    }
  }

  [GraphQLMetadata("Review", IsTypeOf = typeof(Review))]
  public class ReviewResolver
  {
    public string Title(Review review) => review.Title;
    public string Description(Review review) => review.Description;
    public int Grade(Review review) => review.Grade;
    public Product Product(ResolveFieldContext context, Review review)
    {
      return Data.Products.SingleOrDefault(p => p.Id == review.Product);
    }
  }
} 
```

N√£o se esque√ßa de adicionar essa linha `_.Types.Include<ReviewResolver>();` ao `Schema.cs` para que o arquivo tenha agora a seguinte apar√™ncia: 

```csharp
// Schema.cs

using GraphQL.Types;
using GraphQL;

namespace app
{
  public class SchemaFactory
  {
    public static ISchema Create()
    {
      var schema = Schema.For(@"
          type Product {
            id: ID,
            name: String
          }

          type Review {
            grade: Int,
            title: String,
            description: String,
            product: Product
          }

          input ProductInput {
            name: String
          }

          type Mutation {
            createProduct(product: ProductInput): Product
          }

          type Query {
            hello: String,
            products: [Product],
            product(id: ID!): Product,
            reviews: [Review]
          }
      ", _ =>
      {
        _.Types.Include<Query>();
        _.Types.Include<Mutation>();
        _.Types.Include<ReviewResolver>();
      });
      return schema;
    }
  }
}
```

Por fim, vamos experimentar alterando `Program.cs` para:

```csharp
// Program.cs

using System;
using GraphQL;
using GraphQL.Types;

namespace app
{
  class Program
  {
    static void Main(string[] args)
    {
      var schema = SchemaFactory.Create();
      var json = schema.Execute(_ =>
      {
        _.Query = "{ reviews { product { name } } }";
      });

      Console.WriteLine(json);
    }
  }
}
```

Observe como essa linha `_.Query= "{ reviews { product { name } } }"` consulta de maneira aninhada e for√ßa o c√≥digo a resolver a propriedade `product`. Executar isso com `dotnet run` deve fornecer a seguinte sa√≠da:

```json
{
  "data": {
    "reviews": [
      {
        "product": {
          "name": "Avengers - End Game"
        }
      }
    ]
  }
}
```

## Solu√ß√£o

[Introdu√ß√£o √† SOLU√á√ÉO](https://github.com/softchris/graphql-workshop-dotnet/tree/master/part2/dotnet/part1/app)

[Workshop da SOLU√á√ÉO, parte 2](https://github.com/softchris/graphql-workshop-dotnet/tree/master/part2/dotnet/part2/app)