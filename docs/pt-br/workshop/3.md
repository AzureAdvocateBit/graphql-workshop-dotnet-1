---
title: üì¶ Microsservi√ßos e o Docker
---
# üì¶ Microsservi√ßos e o Docker

## Microsservi√ßos

Microsservi√ßos s√£o pequenos servi√ßos dedicados que se concentram na resolu√ß√£o de um problema em um dom√≠nio. A ideia √© separar o monol√≠tico (local onde residem todos os servi√ßos) em pequenos servi√ßos independentes. Vamos falar sobre os pr√≥s e os contras dessa abordagem

**Pr√≥s**

- **Podem ser desenvolvidos e implantados de maneira independente**, a implanta√ß√£o de um aplicativo monol√≠tico pode levar algum tempo. Quando muitos desenvolvedores trabalhando na mesma base de c√≥digo as mesclagens podem ser complicadas. Com os microsservi√ßos tudo isso desaparece, pois h√° reposit√≥rios dedicados para cada microsservi√ßo. Voc√™ pode ativar ou reimplantar seu servi√ßo sem ativar grandes recursos computacionais. 
- **Diferentes equipes podem trabalhar em servi√ßos distintos**, fica muito mais f√°cil escalar verticalmente sua opera√ß√£o de TI com uma equipe por microsservi√ßo.
- **Diferentes servi√ßos podem ser criados em linguagens de programa√ß√£o distintas**, sua empresa n√£o precisa mais ter apenas *uma* pilha de tecnologia. Com esse grau de liberdade, os desenvolvedores contratados poder√£o usar as ferramentas e a linguagem de programa√ß√£o que preferirem para criar os servi√ßos. 
- **F√°cil de escalar** com um orquestrador como o Kubernetes. Como os microsservi√ßos est√£o se transformando em cont√™ineres fica muito f√°cil escalar verticalmente o n√∫mero de inst√¢ncias de microsservi√ßos necess√°rio para atender √†s demandas de usu√°rio, como uma grande venda ou algo semelhante. Gra√ßas ao Kubernetes isso √© muito f√°cil.

**Contras**

- Voc√™ precisa aprender mais sobre cont√™ineres, pois √© assim que voc√™ geralmente entrega seus microsservi√ßos 
- A orquestra√ß√£o se torna um problema que voc√™ precisa gerenciar. √â necess√°rio encontrar uma forma simples de criar cont√™ineres, ativ√°-los e desativ√°-los
- Servi√ßos cruzados √© um assunto que voc√™ precisa gerenciar
- Leva um tempo para aprender a arquitetar mentalmente e *pensar* sobre microsservi√ßos

## Docker

O Docker ajuda a criar cont√™ineres com base em nos microsservi√ßos. Depois que os microsservi√ßos estiverem sendo entregues como cont√™iner, poderemos efetuar push deles para o registro de cont√™iner na nuvem. Da√≠ em diante, podemos fazer com que o Provedor de Nuvem instancie um servi√ßo de aplicativo do cont√™iner OU podemos dizer a um orquestrador como o Kubernetes para escalar verticalmente o aplicativo em *n* inst√¢ncias de modo que possamos atender a milh√µes de clientes.

Para poder trabalhar de maneira eficiente com o Docker neste workshop, aprenderemos os seguintes conceitos:

- **Dockerfile** ‚Äì Um arquivo do Docker √© a receita para aquilo que voc√™ est√° prestes a criar. O arquivo cont√©m informa√ß√µes como o sistema operacional no qual basear sua imagem, as depend√™ncias que precisam ser instaladas e, claro, informa√ß√µes sobre como copiar e executar o aplicativo dentro do cont√™iner.
- **cont√™iner** ‚Äì Um cont√™iner √© uma caixa preta execut√°vel que tem apenas a fra√ß√£o do tamanho de uma VM. O motivo disso √© que o cont√™iner se comunica com o sistema operacional do host em vez de manter um sistema operacional completo dentro do cont√™iner.
- **imagem** ‚Äì Uma imagem √© aquilo que voc√™ obt√©m ao criar um artefato de um Dockerfile. Uma imagem n√£o √© execut√°vel e precisa primeiro ser convertida em um cont√™iner
- **docker-compose** ‚Äì O docker-compose √© uma ferramenta usada quando voc√™ precisa gerenciar v√°rios cont√™ineres de uma s√≥ vez. Sem ele, voc√™ teria que recorrer √† adi√ß√£o de comandos de cria√ß√£o, configura√ß√£o e desmontagem para cada cont√™iner, isso significa muitos scripts e simplesmente se torna dif√≠cil de gerenciar 

## O que vamos criar

Criaremos dois microsservi√ßos diferentes, proporcionando produtos e revis√µes, respectivamente.

Para cada servi√ßo, executaremos as seguintes etapas:

- **Criar** um Servi√ßo REST no Node.js + Expresso
- **Definir** um Dockerfile ‚Äì precisamos de um Dockerfile para cada servi√ßo 
- **Colocar** em cont√™ineres ‚Äì criaremos uma imagem e um cont√™iner, respectivamente, usando o docker-compose, para termos cada cont√™iner pronto, funcionando e acess√≠vel em um navegador

### Criar um Servi√ßo REST no .NET Core

Criaremos dois servi√ßos diferentes
- `products service`, isso retornar√° uma lista de produtos
- `reviews service`, isso conter√° informa√ß√µes sobre uma revis√£o e um vincular√° a uma ID de produto

**Servi√ßo de produtos**

```bash
> dotnet new webapi -o products --no-https
```

Adicione o arquivo `DefaultController.cs` ao diret√≥rio `Controllers` e d√™ a ele o seguinte conte√∫do:

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;

namespace products.Controllers
{
  public class Product
  {
    public int Id { get; set; }
    public string Name { get; set; }
  }

  public class ProductsStore 
  {
    public static List<Product> Products = new List<Product>()
    {
      new Product()
      {
        Id = 1,
        Name = "Avengers - End Game"
      }
    };
  }

  [ApiController]
  public class DefaultController : ControllerBase 
  {
    [Route("/")]
    public List<Product> GetProducts()
    {
      return ProductsStore.Products;
    }
  }
}
```

Experimente executando `dotnet run` no terminal. V√° para um navegador em `http://localhost:5000`. Isso deve mostrar uma lista de produtos.

Desative o servidor com `CTRL+C`.

**Servi√ßo de Revis√µes**

```bash
> dotnet new webapi -o reviews --no-https
```

Adicione o arquivo `DefaultController.cs` ao diret√≥rio `Controllers` e d√™ a ele o seguinte conte√∫do:

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;

namespace reviews.Controllers
{
  public class Review
  {
    public int Grade { get; set; }
    public string Title { get; set; }
    public string Description { get; set; }
    public int Product { get; set; }
  }

  public class ReviewsStore
  {
    public static List<Review> Reviews = new List<Review>()
    {
      new Review()
      {
        Grade = 5,
        Title = "Great movie",
        Description = "Great actor playing Thanos",
        Product = 1
      }
    };
  }

  [ApiController]
  public class DefaultController : ControllerBase
  {
    [Route("/")]
    public List<Review> GetReviews()
    {
      return ReviewsStore.Reviews;
    }
  }
}
```

Experimente executando `dotnet run` no terminal. V√° para um navegador em `http://localhost:5000`. Isso deve mostrar uma lista de produtos.

Desative o servidor com `CTRL+C`.



### Definir um Dockerfile

Precisamos fazer isso uma vez para cada servi√ßo.

**Adicionar o Dockerfile ao servi√ßo de produtos**

V√° para o diret√≥rio `products` e crie um arquivo chamado `Dockerfile`. 

D√™ a ele o seguinte conte√∫do:

```docker
# Dockerfile

FROM mcr.microsoft.com/dotnet/core/sdk:3.1 AS build
WORKDIR /src
COPY products.csproj .
RUN dotnet restore
COPY . .
RUN dotnet publish -c release -o /app

FROM mcr.microsoft.com/dotnet/core/aspnet:3.1
WORKDIR /app
COPY --from=build /app .
ENTRYPOINT ["dotnet", "products.dll"]
```

**Adicionar o Dockerfile ao servi√ßo de Revis√µes**

V√° para o diret√≥rio `reviews` e crie um arquivo chamado `Dockerfile`. D√™ a ele o seguinte conte√∫do:

```docker
# Dockerfile

FROM mcr.microsoft.com/dotnet/core/sdk:3.1 AS build
WORKDIR /src
COPY reviews.csproj .
RUN dotnet restore
COPY . .
RUN dotnet publish -c release -o /app

FROM mcr.microsoft.com/dotnet/core/aspnet:3.1
WORKDIR /app
COPY --from=build /app .
ENTRYPOINT ["dotnet", "reviews.dll"]
```

**Converter para Docker**

Criamos um Dockerfile para cada servi√ßo. Agora, a estrutura do projeto deve ser algo como o seguinte:

```
products/
  -- .net core specific files
  Dockerfile
reviews/
  -- .net core specific files
  Dockerfile
```

Vamos verificar se estamos no n√≠vel raiz e criar um arquivo chamado `docker-compose.yaml`. D√™ a ele o seguinte conte√∫do:

```yaml
version: '3.3'
services: 
  product-service:
    build:
      context: ./products
    ports:
      - "8000:80"
    networks: 
      - microservices
  review-service:
    build:
      context: ./reviews
    ports:
      - "8001:80"
    networks:
      - microservices
networks: 
  microservices:
```

O que o arquivo acima diz √©: Para cada servi√ßo:
1. **executar** o Dockerfile listado em `context`
2. **configurar** uma conex√£o entre a porta do sistema host e a porta do cont√™iner `<host system port>:<container port>`
3. **colocar** cada cont√™iner na rede `microservices`

Agora, a estrutura do projeto deve ser como o seguinte:

Se √â a primeira vez, s√≥ precisamos executar o comando:

```bash
> docker-compose up -d
```

Isso criar√° uma imagem de cada servi√ßo, depois criar√° e executar√° um cont√™iner.

Se N√ÉO √â a primeira vez, em vez disso, execute o seguinte comando:

```bash
> docker-compose build
> docker-compose up -d
```

Observe que executamos o comando `build` para garantir que as altera√ß√µes feitas no Dockerfile sejam recriadas em uma nova imagem.

Isso deve ter iniciado todos os servi√ßos e voc√™ poder√° acess√°-los em `http://localhost:8000` e `http://localhost:8001`. 

Para desativar o tipo de servi√ßos (sem necessidade ainda):

```bash
> docker-compose down
```

## Solu√ß√£o

[Workshop da SOLU√á√ÉO, parte 3](https://github.com/softchris/graphql-workshop-dotnet/tree/master/part3)